<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Misc - Explained</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css">
    <link rel="stylesheet" href="../styles/utilities.css">

    <script defer src="https://use.fontawesome.com/releases/v5.0.7/js/all.js" type="text/javascript"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.min.js" type="text/javascript"></script>
    <script src="../scripts/mustache.js" type="text/javascript"></script>
    <script src="../scripts/jquery_mustache.js" type="text/javascript"></script>
  </head>
  <body>

    <script type="text/javascript">
      $.Mustache.load('../templates/header.mustache', function() {
  	    $('#header').mustache('header', {});
  	});
      $.Mustache.load('../templates/footer.mustache', function() {
  	    $('#footer').mustache('footer', {});
  	});
    </script>

    <div id="header"></div>

    <section class="hero is-primary">
      <div class="hero-body">
        <div class="container">
          <h1 class="title">
            Object-oriented programming
          </h1>
          <h2 class="subtitle">
            Pros and Cons in Data Science context
          </h2>
        </div>
      </div>
    </section>

	<section class="section">
	  <div class="container content">
	    <h1>Table of contents</h1>
	    <ul>
	      <li><a href="#foreword">Foreword</a></li>
	      <li><a href="#when_it_is_needed">When it is needed</a></li>
	      <li><a href="#basic_concepts">Basic concepts</a>
	      <ul>
	        <li><a href="#encapsulation">Encapsulation</a></li>
	        <li><a href="#inheritance">Inheritance</a></li>
	        <li><a href="#polymorphism">Polymorphism</a></li>
	      </ul>
	      <li><a href="#solid_principles">SOLID Principles</a></li>
	      <ul>
	        <li><a href="#sr">Single Responsibility</a></li>
            <li><a href="#oc">Open/Closed</a></li>
            <li><a href="#ls">Liskov Substitution</a></li>
            <li><a href="#is">Interface Segregation</a></li>
            <li><a href="#di">Dependency Inversion</a></li>
	      </ul>
	      <li><a href="#patterns">Patterns</a></li>
	      <li><a href="#fp_and_oop">FP and OOP</a></li>
	    </ul>

        <h1 id="foreword">Foreword</h1>

        The job of Data Scientist is mostly about applying statistics and modern math. It is also about programming. 
        But it is usually not about object-oriented design and applications development. However, knowing the basics 
        of OOP can make Data Scientist's life easier. Applied right, this technique increases maintainability and 
        reusability of the code. Good news is that Python, as one of the most used languages in DS, does not enforce 
        a lot of classic OOP principles. It allows creating OO-code in a less strict manner than Java. Multiparadigm 
        nature of Python even makes the presence of OO-capability of this language less obvious until some point.

        <h1 id="when_it_is_needed">When it is needed</h1>

        The main point I am making here is that OOP is not a silver bullet and should be used wisely as any other technique.
        OOP is needed when there is a mutable state that should be handled. In fact, a problem of handling a mutable state 
        led to an introduction of this paradigm. Objects can isolate different concepts of a software system in terms of
        data and processing flow.

        <h1 id="basic_concepts">Basic concepts</h1>

        <h2 id="encapsulation">Encapsulation</h2>

        Isolating state and behavior of some entity of business domain. Or just some entity with known and clearly defined intends.

        <h2 id="inheritance">Inheritance</h2>

        A beast that has to be used less often than the books say it should. Besides introducing a level of abstraction
        and the means for code reuse, it also can introduce troubles of subclasses being too heavy or fragile.
        When they are heavy, it is hard to instantiate them, because a lot of dependencies are required for them to run.
        When classes are fragile, it is difficult to extend them properly. Sometimes one can forget to override some 
        methods hidden deeply in abstract superclasses. Both heaviness and fragility are introduced with inheritance, 
        but the issue here is its overuse, not the technique itself.

        <h2 id="polymorphism">Polymorphism</h2>

        A powerful feature of OOP which is less obvious in Python rather than in Java. It applies to class hierarchies. 
        Consider a base class that has two inheritors. All of them have a method named identically but implemented differently
        in all classes. Then consider a function that accepts any class object from this hierarchy as a parameter. 
        One can call the method of the object in the function without knowing exactly the object of which class was passed. 
        This is a polymorphism in action.

        <h2 id="solid_principles"><a href="https://en.wikipedia.org/wiki/SOLID">SOLID Principles</a></h2>

        These principles are hard to fully understand without a lot of practice. Usually, one's design fails if one or several
        principles are violated. A simple examples of applying the principles on bad designs can be found on
        <a href="https://github.com/dboyliao/SOLID">GitHub</a>.

        <ul>
          <li id="sr">Single Responsibility</li>
          <p>A class maintains only one entity of business domain or addresses one particular issue. For example, a class that
          implements list should not mess with the items it stores.</p>

          <li id="oc">Open/Closed</li>
          <p>A class should be opened to an extension but closed for modification. This principle is formulated in a mysterious 
          way. Essentially, it means that one should not modify a class to extend it. So it is related to proper use of encapsulation.</p>

          <li id="ls">Liskov Substitution</li>
          <p>A superclass can be used instead of base class everywhere. This principle related to polymorphism. If polymorphism 
          is implemented properly, then the principle does not get violated. For example, an inheritor always should extend its
          parent by adding more details but not reducing its functionality by any means.</p>

          <li id="is">Interface Segregation</li>
          <p>Many specific interfaces are better than one generic. It means that introducing a generic interface for all purposes 
          is a bad idea. Eventually, this design decision would lead to multitudes of irrelevant method implementations in subclasses.</p>

          <li id="di">Dependency Inversion</li>
          <p>A class should depend on the most generic version of its dependency. Adhering to this principle makes usage of 
          polymorphism possible.

          Also, problems are often caused by violation of YAGNI and KISS principles. However, it is not an OO-specific issue.</p>

        </ul>

        <h1 id="patterns">Patterns</h1>

        The idea of patterns is to bring a solution of the known problem in the current context. I do not think that knowing 
        of OO-patterns is crucial for Data Scientist. Nevertheless one should know they exist and check them out someday when
        the design of one's code does not satisfy anymore.

        <h1 id="fp_and_oop">FP and OOP</h1>

        Surprisingly, functional and OO-programming is sometimes considered as mutually exclusive approaches. However, they 
        can work together well. Python treats functions as first-class citizens. Passing them as parameters is widely used. 
        Replacing object's methods at runtime by setting a function or lambda to them is also just fine. It allows providing
        unit testing without bothering about mocks.
	  </div>
	</section>

    <div id="wrapper"></div>
    <div id="footer"></div>

  </body>
</html>
